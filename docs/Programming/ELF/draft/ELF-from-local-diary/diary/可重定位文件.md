# [可重定位文件](https://blog.csdn.net/ylcangel/article/details/18188921)

## 可重定位目标

**重定位**是将EFL文件中的**未定义符号**（包括函数和变量）关联到**有效值**（？？什么是有效值）的处理过程。在main.o中，这意味着对printf和puts的未定义的引用必须替换为该**进程的虚拟地址空间**中适当的**机器代码**所在的**地址**。在目标中用到的相关**符号**之处，都必须替换。

对*用户空间*  **程序符号**的替换，**内核**并不涉及其中，因为所有的替换操作都是由**外部工具**完成的。对内核模块来说，情况有所不同，因为内核所收到的**模块裸数据**，与其存储在二级制文件中的形式完全相同，内核本身需要负责重定位操作。

在每个**目标文件**中，都有一个专门的表，包含了**重定位项**，标识了需要进行重定位的。每个**表项**都包含下列信息：

​         1）一个**偏移量**，指定了修改的项的位置

​         2）对**符号**的**引用**（符号表的**索引**），提供了需要插入到**重定位位置**的数据

## 重定位步骤

​         1）重定位节(section)和符号定义。

​         **链接器**将所有**相同类型的节**合并为同一类型的新的**聚合节**。例如来自输入模块的.data节全部合并成一个节，这个节成为输出可执行目标文件的.data节。然后**链接器**将运行时**存储器地址**赋给新的**聚合节**，赋给输入模块定义的每个节，以及赋给输入模块定义的每个**符号**。当这一步完成时，程序中的每个**指令**和**全局变量**都有唯一的**运行时存储器地址**了。

​         2）重定位节(section)中的符号引用。

​         在这一步中，链接器修改**代码节**和**数据节**中对每个**符号**的**引用**(？？此处的引用要如何理解），使得他们指向**正确的运行时地址**。为了执行这一步，链接器依赖于称之为**重定位条目**的可重定位目标模块中的数据结构。

## 重定向条目

当**汇编器**生成一个**目标模块**时，它并不知道**数据**和**代码**最终将存放在**存储器**中的什么位置。它也不知道这个模块引用的任何外部定义的**函数**和**全局变量**。所以，无论何时**汇编器**遇到对最终位置未指定**目标引用**（？？此处的目标引用要如何理解），它就会生成一个**重定位条目**，告诉**链接器**在将**目标文件**合并**可执行文件**时如何修改这个**引用**。**代码重定位条目**放在.rel.text（**SHT_REL类型**的节（section））中。**已经初始化数据的重定位条目**放在.rel.data(**SHT_REL类型**的节（section）)中。

### 数据结构

​         由于技术原因，有两种类型的重定位信息，由两种稍有不同的数据结构表示。第一种类型称之为**普通重定位**。**SHT_REL类型**的节（section）中的**重定位项**由以下数据结构定义：

```       c
/*Relocation table entry without addend (in section of type SHT_REL).  */
typedef struct
{

 Elf32_Addr   r_offset;/* Address 指定需要重定位的项的位置*/
 Elf32_Word  r_info;/* Relocation type andsymbol index 提供了符号表中的一个位置，同时还包括重定位类型的有个信息。这是通过将值划分为两部分来达到的。该字段的结构如下：
        r_info == int symbol:24,type:8;*/

} Elf32_Rel;

```
另一种类型，称之为需要添加常数的**重定位项**，只出现在SHT_RELA类型的节中。数据结构如下：

```c
/* Relocation table entry with addend (insection of type SHT_RELA).  */
typedef struct
{
 Elf32_Addr   r_offset;            /* Address */
 Elf32_Word  r_info;                         /* Relocation type andsymbol index */
 Elf32_Sword         r_addend;                  /* Addend 加数，计算重定位是，将根据重定位类型，对该值进行不同的处理。*/

} Elf32_Rela;
```

