[TOC]

# 1.6.3. Reentrant Kernels

All Unix kernels are *reentrant*. This means that several processes may be executing in **Kernel Mode**
at the same time. Of course, on uniprocessor systems, only one process can progress, but many can
be blocked in **Kernel Mode** when waiting for the CPU or the completion of some I/O operation. For
instance, after issuing a read to a disk on behalf of a process, the kernel lets the **disk controller**
handle it and resumes executing other processes. An **interrupt** notifies the kernel when the device
has satisfied the read, so the former process can resume the execution.

One way to provide **reentrancy** is to write functions so that they modify only **local variables** and do
not alter **global data structures**. Such functions are called *reentrant functions* . But a **reentrant
kernel** is not limited only to such **reentrant functions** (although that is how some **real-time kernels**
are implemented). Instead, the kernel can include **nonreentrant functions** and use **locking
mechanisms** to ensure that only one process can execute a **nonreentrant function** at a time.

If a **hardware interrupt** occurs, a **reentrant kernel** is able to suspend the current running process
even if that process is in **Kernel Mode**. This capability is very important, because it improves the
throughput of the **device controllers** that issue interrupts. Once a device has issued an interrupt, it
waits until the **CPU** **acknowledges** it. If the kernel is able to answer quickly, the **device controller** will
be able to perform other tasks while the CPU handles the interrupt.

Now let's look at **kernel reentrancy** and its impact on the organization of the kernel. A *kernel control
path* denotes the sequence of instructions executed by the kernel to handle a **system call**, an
**exception**, or an **interrupt**.

In the simplest case, the CPU executes a **kernel control path** sequentially from the first instruction to
the last. When one of the following events occurs, however, the CPU interleaves the kernel control
paths :

- A process executing in User Mode invokes a **system call**, and the corresponding **kernel control
  path** verifies that the request cannot be satisfied immediately; it then invokes the **scheduler** to
  select a new process to run. As a result, a **process switch** occurs. The first **kernel control path** is
  left unfinished, and the CPU resumes the execution of some other **kernel control path**. In this
  case, the two **control paths** are executed on behalf of two different processes.
- The CPU detects an exception for example, access to a page not present in RAM while running a
  **kernel control path**. The first control path is suspended, and the CPU starts the execution of a
  suitable procedure. In our example, this type of procedure can allocate a new page for the
  process and read its contents from disk. When the procedure terminates, the first control path
  can be resumed. In this case, the two control paths are executed on behalf of the same
  process.
- A hardware interrupt occurs while the CPU is running a kernel control path with the interrupts
  enabled. The first kernel control path is left unfinished, and the CPU starts processing another
  kernel control path to handle the interrupt. The first kernel control path resumes when the
  interrupt handler terminates. In this case, the two kernel control paths run in the execution
  context of the same process, and the total system CPU time is accounted to it. However, the
  interrupt handler doesn't necessarily operate on behalf of the process.
- An interrupt occurs while the CPU is running with kernel preemption enabled, and a higher
  priority process is runnable. In this case, the first kernel control path is left unfinished, and the
  CPU resumes executing another kernel control path on behalf of the higher priority process.
  This occurs only if the kernel has been compiled with kernel preemption support.

