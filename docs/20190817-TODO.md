今天在阅读《`Understanding.The.Linux.kernel.3rd.Edition`》的6.2.1.2. The jiffies variable章节的时候，其中的一段话引起了我对原子性的思考：

> You might wonder why  `jiffies` has not been directly declared as a 64-bit  `unsigned long long` integer on the 80 x 86 architecture. The answer is that accesses to 64-bit variables in 32-bit architectures cannot be done **atomically**. Therefore, every read operation on the whole 64 bits requires some synchronization technique to ensure that the counter is not updated while the two 32-bit half-counters are read; as a consequence, every 64-bit read operation is significantly slower than a 32-bit read operation.

在32位的机器中，一次能够读取的数据的长度为32位，所以读取超过32的数据就需要多条指令，显然，这就不是原子性的了；

联想到今天在阅读《计算机组成原理》的1.2.4 计算机的性能指标，我所做的笔记如下：

> 指处理机**运算器**中一次能够完成二进制数运算的**位数**，如32位，64位；
>
> **SUMMARY** : 这应该就是我们平时所说的32位，或64位；一次能够完成二进制数的运算，其实蕴含中，CPU一次CPU一次性能读取数据的二进制位数。参见[Redis内存管理的基石zmallc.c源码解读（一）](https://blog.csdn.net/guodongxiaren/article/details/44747719) ； [Data alignment: Straighten up and fly right](https://developer.ibm.com/articles/pa-dalign/)
>
> **SUMMARY** : 上述一次的含义是什么？是指一个指令周期？



现在联系到原子性，显然，上述这段话中的**一次**的含义是非常深刻的：它蕴含着原子性的保证；



其实这个问题，我在之前就已经遇到过的，记得当时阅读的文章是：[Atomic vs. Non-Atomic Operations](https://preshing.com/20130618/atomic-vs-non-atomic-operations/)，这篇文章我已经收录了；

综上所述，其实我的问题可以归纳为：why read 64 bit data in 32 bit is not atomic

Google了一下，发现了一些有价值的内容：

- [How to Customize Serialization in Java Using the Externalizable Interface](https://dzone.com/articles/how-to-customize-serialization-in-java-using-the-e)
- [Are 64 bit operations atomic for a 32 bit app on 64 bit Windows](https://stackoverflow.com/questions/27533611/are-64-bit-operations-atomic-for-a-32-bit-app-on-64-bit-windows)

